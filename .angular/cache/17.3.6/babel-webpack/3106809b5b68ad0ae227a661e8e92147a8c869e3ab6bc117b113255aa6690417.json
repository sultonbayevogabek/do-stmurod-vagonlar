{"ast":null,"code":"import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { merge } from 'lodash-es';\nimport PerfectScrollbar from 'perfect-scrollbar';\nimport { debounceTime, fromEvent, Subject, takeUntil } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/cdk/platform\";\nexport class ScrollbarDirective {\n  constructor(_elementRef, _platform) {\n    this._elementRef = _elementRef;\n    this._platform = _platform;\n    /* eslint-enable @typescript-eslint/naming-convention */\n    this.scrollbar = true;\n    this._unsubscribeAll = new Subject();\n  }\n  get elementRef() {\n    return this._elementRef;\n  }\n  /**\n   * Getter for _ps\n   */\n  get ps() {\n    return this._ps;\n  }\n  ngOnChanges(changes) {\n    // Enabled\n    if ('scrollbar' in changes) {\n      // Interpret empty string as 'true'\n      this.scrollbar = coerceBooleanProperty(changes['scrollbar'].currentValue);\n      // If enabled, init the directive\n      if (this.scrollbar) {\n        this._init();\n      }\n      // Otherwise destroy it\n      else {\n        this._destroy();\n      }\n    }\n    // Scrollbar options\n    if ('scrollbarOptions' in changes) {\n      // Merge the options\n      this._options = merge({}, this._options, changes['scrollbarOptions'].currentValue);\n      // Return if not initialized\n      if (!this._ps) {\n        return;\n      }\n      // Destroy and re-init the PerfectScrollbar to update its options\n      setTimeout(() => {\n        this._destroy();\n      });\n      setTimeout(() => {\n        this._init();\n      });\n    }\n  }\n  /**\n   * On init\n   */\n  ngOnInit() {\n    // Subscribe to window resize event\n    fromEvent(window, 'resize').pipe(takeUntil(this._unsubscribeAll), debounceTime(150)).subscribe(() => {\n      // Update the PerfectScrollbar\n      this.update();\n    });\n  }\n  /**\n   * On destroy\n   */\n  ngOnDestroy() {\n    this._destroy();\n    // Unsubscribe from all subscriptions\n    this._unsubscribeAll.next(null);\n    this._unsubscribeAll.complete();\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Is enabled\n   */\n  isEnabled() {\n    return this.scrollbar;\n  }\n  /**\n   * Update the scrollbar\n   */\n  update() {\n    // Return if not initialized\n    if (!this._ps) {\n      return;\n    }\n    // Update the PerfectScrollbar\n    this._ps.update();\n  }\n  /**\n   * Destroy the scrollbar\n   */\n  destroy() {\n    this.ngOnDestroy();\n  }\n  /**\n   * Returns the geometry of the scrollable element\n   *\n   * @param prefix\n   */\n  geometry(prefix = 'scroll') {\n    return new ScrollbarGeometry(this._elementRef.nativeElement[prefix + 'Left'], this._elementRef.nativeElement[prefix + 'Top'], this._elementRef.nativeElement[prefix + 'Width'], this._elementRef.nativeElement[prefix + 'Height']);\n  }\n  /**\n   * Returns the position of the scrollable element\n   *\n   * @param absolute\n   */\n  position(absolute = false) {\n    let scrollbarPosition;\n    if (!absolute && this._ps) {\n      scrollbarPosition = new ScrollbarPosition(this._ps.reach.x || 0, this._ps.reach.y || 0);\n    } else {\n      scrollbarPosition = new ScrollbarPosition(this._elementRef.nativeElement.scrollLeft, this._elementRef.nativeElement.scrollTop);\n    }\n    return scrollbarPosition;\n  }\n  /**\n   * Scroll to\n   *\n   * @param x\n   * @param y\n   * @param speed\n   */\n  scrollTo(x, y, speed) {\n    if (y == null && speed == null) {\n      this.animateScrolling('scrollTop', x, speed);\n    } else {\n      if (x != null) {\n        this.animateScrolling('scrollLeft', x, speed);\n      }\n      if (y != null) {\n        this.animateScrolling('scrollTop', y, speed);\n      }\n    }\n  }\n  /**\n   * Scroll to X\n   *\n   * @param x\n   * @param speed\n   */\n  scrollToX(x, speed) {\n    this.animateScrolling('scrollLeft', x, speed);\n  }\n  /**\n   * Scroll to Y\n   *\n   * @param y\n   * @param speed\n   */\n  scrollToY(y, speed) {\n    this.animateScrolling('scrollTop', y, speed);\n  }\n  /**\n   * Scroll to top\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToTop(offset = 0, speed) {\n    this.animateScrolling('scrollTop', offset, speed);\n  }\n  /**\n   * Scroll to bottom\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToBottom(offset = 0, speed) {\n    const top = this._elementRef.nativeElement.scrollHeight - this._elementRef.nativeElement.clientHeight;\n    this.animateScrolling('scrollTop', top - offset, speed);\n  }\n  /**\n   * Scroll to left\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToLeft(offset = 0, speed) {\n    this.animateScrolling('scrollLeft', offset, speed);\n  }\n  /**\n   * Scroll to right\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToRight(offset = 0, speed) {\n    const left = this._elementRef.nativeElement.scrollWidth - this._elementRef.nativeElement.clientWidth;\n    this.animateScrolling('scrollLeft', left - offset, speed);\n  }\n  /**\n   * Scroll to element\n   *\n   * @param qs\n   * @param offset\n   * @param ignoreVisible If true, scrollToElement won't happen if element is already inside the current viewport\n   * @param speed\n   */\n  scrollToElement(qs, offset = 0, ignoreVisible = false, speed) {\n    const element = this._elementRef.nativeElement.querySelector(qs);\n    if (!element) {\n      return;\n    }\n    const elementPos = element.getBoundingClientRect();\n    const scrollerPos = this._elementRef.nativeElement.getBoundingClientRect();\n    if (this._elementRef.nativeElement.classList.contains('ps--active-x')) {\n      if (ignoreVisible && elementPos.right <= scrollerPos.right - Math.abs(offset)) {\n        return;\n      }\n      const currentPos = this._elementRef.nativeElement['scrollLeft'];\n      const position = elementPos.left - scrollerPos.left + currentPos;\n      this.animateScrolling('scrollLeft', position + offset, speed);\n    }\n    if (this._elementRef.nativeElement.classList.contains('ps--active-y')) {\n      if (ignoreVisible && elementPos.bottom <= scrollerPos.bottom - Math.abs(offset)) {\n        return;\n      }\n      const currentPos = this._elementRef.nativeElement['scrollTop'];\n      const position = elementPos.top - scrollerPos.top + currentPos;\n      this.animateScrolling('scrollTop', position + offset, speed);\n    }\n  }\n  /**\n   * Animate scrolling\n   *\n   * @param target\n   * @param value\n   * @param speed\n   */\n  animateScrolling(target, value, speed) {\n    if (this._animation) {\n      window.cancelAnimationFrame(this._animation);\n      this._animation = null;\n    }\n    if (!speed || typeof window === 'undefined') {\n      this._elementRef.nativeElement[target] = value;\n    } else if (value !== this._elementRef.nativeElement[target]) {\n      let newValue = 0;\n      let scrollCount = 0;\n      let oldTimestamp = performance.now();\n      let oldValue = this._elementRef.nativeElement[target];\n      const cosParameter = (oldValue - value) / 2;\n      const step = newTimestamp => {\n        scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));\n        newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount));\n        // Only continue animation if scroll position has not changed\n        if (this._elementRef.nativeElement[target] === oldValue) {\n          if (scrollCount >= Math.PI) {\n            this.animateScrolling(target, value, 0);\n          } else {\n            this._elementRef.nativeElement[target] = newValue;\n            // On a zoomed out page the resulting offset may differ\n            oldValue = this._elementRef.nativeElement[target];\n            oldTimestamp = newTimestamp;\n            this._animation = window.requestAnimationFrame(step);\n          }\n        }\n      };\n      window.requestAnimationFrame(step);\n    }\n  }\n  // -----------------------------------------------------------------------------------------------------\n  // @ Private methods\n  // -----------------------------------------------------------------------------------------------------\n  /**\n   * Initialize\n   *\n   * @private\n   */\n  _init() {\n    // Return if already initialized\n    if (this._ps) {\n      return;\n    }\n    // Return if on mobile or not on browser\n    if (this._platform.ANDROID || this._platform.IOS || !this._platform.isBrowser) {\n      this.scrollbar = false;\n      return;\n    }\n    // Initialize the PerfectScrollbar\n    this._ps = new PerfectScrollbar(this._elementRef.nativeElement, {\n      ...this._options\n    });\n  }\n  /**\n   * Destroy\n   *\n   * @private\n   */\n  _destroy() {\n    // Return if not initialized\n    if (!this._ps) {\n      return;\n    }\n    // Destroy the PerfectScrollbar\n    this._ps.destroy();\n    // Clean up\n    this._ps = null;\n  }\n  static #_ = this.ɵfac = function ScrollbarDirective_Factory(t) {\n    return new (t || ScrollbarDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.Platform));\n  };\n  static #_2 = this.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: ScrollbarDirective,\n    selectors: [[\"\", \"scrollbar\", \"\"]],\n    inputs: {\n      scrollbar: \"scrollbar\",\n      scrollbarOptions: \"scrollbarOptions\"\n    },\n    exportAs: [\"scrollbar\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\nexport class ScrollbarGeometry {\n  constructor(x, y, w, h) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n  }\n}\nexport class ScrollbarPosition {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}","map":{"version":3,"names":["coerceBooleanProperty","merge","PerfectScrollbar","debounceTime","fromEvent","Subject","takeUntil","ScrollbarDirective","constructor","_elementRef","_platform","scrollbar","_unsubscribeAll","elementRef","ps","_ps","ngOnChanges","changes","currentValue","_init","_destroy","_options","setTimeout","ngOnInit","window","pipe","subscribe","update","ngOnDestroy","next","complete","isEnabled","destroy","geometry","prefix","ScrollbarGeometry","nativeElement","position","absolute","scrollbarPosition","ScrollbarPosition","reach","x","y","scrollLeft","scrollTop","scrollTo","speed","animateScrolling","scrollToX","scrollToY","scrollToTop","offset","scrollToBottom","top","scrollHeight","clientHeight","scrollToLeft","scrollToRight","left","scrollWidth","clientWidth","scrollToElement","qs","ignoreVisible","element","querySelector","elementPos","getBoundingClientRect","scrollerPos","classList","contains","right","Math","abs","currentPos","bottom","target","value","_animation","cancelAnimationFrame","newValue","scrollCount","oldTimestamp","performance","now","oldValue","cosParameter","step","newTimestamp","PI","round","cos","requestAnimationFrame","ANDROID","IOS","isBrowser","_","i0","ɵɵdirectiveInject","ElementRef","i1","Platform","_2","selectors","inputs","scrollbarOptions","exportAs","standalone","features","ɵɵNgOnChangesFeature","w","h"],"sources":["/Users/sultonbayevogabek/Projects/do-stmurod-vagonlar/src/app/config/directives/scrollbar.directive.ts"],"sourcesContent":["import { BooleanInput, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform } from '@angular/cdk/platform';\nimport { Directive, ElementRef, Input, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';\nimport { merge } from 'lodash-es';\nimport PerfectScrollbar from 'perfect-scrollbar';\nimport { debounceTime, fromEvent, Subject, takeUntil } from 'rxjs';\n\n@Directive({\n  selector: '[scrollbar]',\n  exportAs: 'scrollbar',\n  standalone: true\n})\n\nexport class ScrollbarDirective implements OnChanges, OnInit, OnDestroy {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  static ngAcceptInputType_scrollbar: BooleanInput;\n  /* eslint-enable @typescript-eslint/naming-convention */\n\n  @Input() scrollbar: boolean = true;\n  @Input() scrollbarOptions: PerfectScrollbar.Options;\n\n  private _animation: number;\n  private _options: PerfectScrollbar.Options;\n  private _ps: PerfectScrollbar;\n  private _unsubscribeAll: Subject<any> = new Subject<any>();\n\n  constructor(\n    private _elementRef: ElementRef,\n    private _platform: Platform\n  ) {\n  }\n\n  get elementRef(): ElementRef {\n    return this._elementRef;\n  }\n\n  /**\n   * Getter for _ps\n   */\n  get ps(): PerfectScrollbar | null {\n    return this._ps;\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    // Enabled\n    if ('scrollbar' in changes) {\n      // Interpret empty string as 'true'\n      this.scrollbar = coerceBooleanProperty(changes['scrollbar'].currentValue);\n\n      // If enabled, init the directive\n      if (this.scrollbar) {\n        this._init();\n      }\n      // Otherwise destroy it\n      else {\n        this._destroy();\n      }\n    }\n\n    // Scrollbar options\n    if ('scrollbarOptions' in changes) {\n      // Merge the options\n      this._options = merge({}, this._options, changes['scrollbarOptions'].currentValue);\n\n      // Return if not initialized\n      if (!this._ps) {\n        return;\n      }\n\n      // Destroy and re-init the PerfectScrollbar to update its options\n      setTimeout(() => {\n        this._destroy();\n      });\n\n      setTimeout(() => {\n        this._init();\n      });\n    }\n  }\n\n  /**\n   * On init\n   */\n  ngOnInit(): void {\n    // Subscribe to window resize event\n    fromEvent(window, 'resize')\n      .pipe(\n        takeUntil(this._unsubscribeAll),\n        debounceTime(150)\n      )\n      .subscribe(() => {\n        // Update the PerfectScrollbar\n        this.update();\n      });\n  }\n\n  /**\n   * On destroy\n   */\n  ngOnDestroy(): void {\n    this._destroy();\n\n    // Unsubscribe from all subscriptions\n    this._unsubscribeAll.next(null);\n    this._unsubscribeAll.complete();\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Public methods\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Is enabled\n   */\n  isEnabled(): boolean {\n    return this.scrollbar;\n  }\n\n  /**\n   * Update the scrollbar\n   */\n  update(): void {\n    // Return if not initialized\n    if (!this._ps) {\n      return;\n    }\n\n    // Update the PerfectScrollbar\n    this._ps.update();\n  }\n\n  /**\n   * Destroy the scrollbar\n   */\n  destroy(): void {\n    this.ngOnDestroy();\n  }\n\n  /**\n   * Returns the geometry of the scrollable element\n   *\n   * @param prefix\n   */\n  geometry(prefix: string = 'scroll'): ScrollbarGeometry {\n    return new ScrollbarGeometry(\n      this._elementRef.nativeElement[prefix + 'Left'],\n      this._elementRef.nativeElement[prefix + 'Top'],\n      this._elementRef.nativeElement[prefix + 'Width'],\n      this._elementRef.nativeElement[prefix + 'Height']);\n  }\n\n  /**\n   * Returns the position of the scrollable element\n   *\n   * @param absolute\n   */\n  position(absolute: boolean = false): ScrollbarPosition {\n    let scrollbarPosition;\n\n    if (!absolute && this._ps) {\n      scrollbarPosition = new ScrollbarPosition(\n        this._ps.reach.x || 0,\n        this._ps.reach.y || 0\n      );\n    } else {\n      scrollbarPosition = new ScrollbarPosition(\n        this._elementRef.nativeElement.scrollLeft,\n        this._elementRef.nativeElement.scrollTop\n      );\n    }\n\n    return scrollbarPosition;\n  }\n\n  /**\n   * Scroll to\n   *\n   * @param x\n   * @param y\n   * @param speed\n   */\n  scrollTo(x: number, y?: number, speed?: number): void {\n    if (y == null && speed == null) {\n      this.animateScrolling('scrollTop', x, speed);\n    } else {\n      if (x != null) {\n        this.animateScrolling('scrollLeft', x, speed);\n      }\n\n      if (y != null) {\n        this.animateScrolling('scrollTop', y, speed);\n      }\n    }\n  }\n\n  /**\n   * Scroll to X\n   *\n   * @param x\n   * @param speed\n   */\n  scrollToX(x: number, speed?: number): void {\n    this.animateScrolling('scrollLeft', x, speed);\n  }\n\n  /**\n   * Scroll to Y\n   *\n   * @param y\n   * @param speed\n   */\n  scrollToY(y: number, speed?: number): void {\n    this.animateScrolling('scrollTop', y, speed);\n  }\n\n  /**\n   * Scroll to top\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToTop(offset: number = 0, speed?: number): void {\n    this.animateScrolling('scrollTop', offset, speed);\n  }\n\n  /**\n   * Scroll to bottom\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToBottom(offset: number = 0, speed?: number): void {\n    const top = this._elementRef.nativeElement.scrollHeight - this._elementRef.nativeElement.clientHeight;\n    this.animateScrolling('scrollTop', top - offset, speed);\n  }\n\n  /**\n   * Scroll to left\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToLeft(offset: number = 0, speed?: number): void {\n    this.animateScrolling('scrollLeft', offset, speed);\n  }\n\n  /**\n   * Scroll to right\n   *\n   * @param offset\n   * @param speed\n   */\n  scrollToRight(offset: number = 0, speed?: number): void {\n    const left = this._elementRef.nativeElement.scrollWidth - this._elementRef.nativeElement.clientWidth;\n    this.animateScrolling('scrollLeft', left - offset, speed);\n  }\n\n  /**\n   * Scroll to element\n   *\n   * @param qs\n   * @param offset\n   * @param ignoreVisible If true, scrollToElement won't happen if element is already inside the current viewport\n   * @param speed\n   */\n  scrollToElement(qs: string, offset: number = 0, ignoreVisible: boolean = false, speed?: number): void {\n    const element = this._elementRef.nativeElement.querySelector(qs);\n\n    if (!element) {\n      return;\n    }\n\n    const elementPos = element.getBoundingClientRect();\n    const scrollerPos = this._elementRef.nativeElement.getBoundingClientRect();\n\n    if (this._elementRef.nativeElement.classList.contains('ps--active-x')) {\n      if (ignoreVisible && elementPos.right <= (scrollerPos.right - Math.abs(offset))) {\n        return;\n      }\n\n      const currentPos = this._elementRef.nativeElement['scrollLeft'];\n      const position = elementPos.left - scrollerPos.left + currentPos;\n\n      this.animateScrolling('scrollLeft', position + offset, speed);\n    }\n\n    if (this._elementRef.nativeElement.classList.contains('ps--active-y')) {\n      if (ignoreVisible && elementPos.bottom <= (scrollerPos.bottom - Math.abs(offset))) {\n        return;\n      }\n\n      const currentPos = this._elementRef.nativeElement['scrollTop'];\n      const position = elementPos.top - scrollerPos.top + currentPos;\n\n      this.animateScrolling('scrollTop', position + offset, speed);\n    }\n  }\n\n  /**\n   * Animate scrolling\n   *\n   * @param target\n   * @param value\n   * @param speed\n   */\n  animateScrolling(target: string, value: number, speed?: number): void {\n    if (this._animation) {\n      window.cancelAnimationFrame(this._animation);\n      this._animation = null;\n    }\n\n    if (!speed || typeof window === 'undefined') {\n      this._elementRef.nativeElement[target] = value;\n    } else if (value !== this._elementRef.nativeElement[target]) {\n      let newValue = 0;\n      let scrollCount = 0;\n\n      let oldTimestamp = performance.now();\n      let oldValue = this._elementRef.nativeElement[target];\n\n      const cosParameter = (oldValue - value) / 2;\n\n      const step = (newTimestamp: number): void => {\n        scrollCount += Math.PI / (speed / (newTimestamp - oldTimestamp));\n        newValue = Math.round(value + cosParameter + cosParameter * Math.cos(scrollCount));\n\n        // Only continue animation if scroll position has not changed\n        if (this._elementRef.nativeElement[target] === oldValue) {\n          if (scrollCount >= Math.PI) {\n            this.animateScrolling(target, value, 0);\n          } else {\n            this._elementRef.nativeElement[target] = newValue;\n\n            // On a zoomed out page the resulting offset may differ\n            oldValue = this._elementRef.nativeElement[target];\n            oldTimestamp = newTimestamp;\n\n            this._animation = window.requestAnimationFrame(step);\n          }\n        }\n      };\n\n      window.requestAnimationFrame(step);\n    }\n  }\n\n  // -----------------------------------------------------------------------------------------------------\n  // @ Private methods\n  // -----------------------------------------------------------------------------------------------------\n\n  /**\n   * Initialize\n   *\n   * @private\n   */\n  private _init(): void {\n    // Return if already initialized\n    if (this._ps) {\n      return;\n    }\n\n    // Return if on mobile or not on browser\n    if (this._platform.ANDROID || this._platform.IOS || !this._platform.isBrowser) {\n      this.scrollbar = false;\n      return;\n    }\n\n    // Initialize the PerfectScrollbar\n    this._ps = new PerfectScrollbar(this._elementRef.nativeElement, { ...this._options });\n  }\n\n  /**\n   * Destroy\n   *\n   * @private\n   */\n  private _destroy(): void {\n    // Return if not initialized\n    if (!this._ps) {\n      return;\n    }\n\n    // Destroy the PerfectScrollbar\n    this._ps.destroy();\n\n    // Clean up\n    this._ps = null;\n  }\n}\n\nexport class ScrollbarGeometry {\n  public x: number;\n  public y: number;\n\n  public w: number;\n  public h: number;\n\n  constructor(x: number, y: number, w: number, h: number) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n  }\n}\n\nexport class ScrollbarPosition {\n  public x: number | 'start' | 'end';\n  public y: number | 'start' | 'end';\n\n  constructor(x: number | 'start' | 'end', y: number | 'start' | 'end') {\n    this.x = x;\n    this.y = y;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}