{"ast":null,"code":"// flex-buffer.js\n\nexports.FlexDecoder = FlexDecoder;\nexports.FlexEncoder = FlexEncoder;\nvar Bufferish = require(\"./bufferish\");\nvar MIN_BUFFER_SIZE = 2048;\nvar MAX_BUFFER_SIZE = 65536;\nvar BUFFER_SHORTAGE = \"BUFFER_SHORTAGE\";\nfunction FlexDecoder() {\n  if (!(this instanceof FlexDecoder)) return new FlexDecoder();\n}\nfunction FlexEncoder() {\n  if (!(this instanceof FlexEncoder)) return new FlexEncoder();\n}\nFlexDecoder.mixin = mixinFactory(getDecoderMethods());\nFlexDecoder.mixin(FlexDecoder.prototype);\nFlexEncoder.mixin = mixinFactory(getEncoderMethods());\nFlexEncoder.mixin(FlexEncoder.prototype);\nfunction getDecoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    offset: 0\n  };\n  function write(chunk) {\n    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;\n    this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;\n    this.offset = 0;\n  }\n  function flush() {\n    while (this.offset < this.buffer.length) {\n      var start = this.offset;\n      var value;\n      try {\n        value = this.fetch();\n      } catch (e) {\n        if (e && e.message != BUFFER_SHORTAGE) throw e;\n        // rollback\n        this.offset = start;\n        break;\n      }\n      this.push(value);\n    }\n  }\n  function reserve(length) {\n    var start = this.offset;\n    var end = start + length;\n    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);\n    this.offset = end;\n    return start;\n  }\n}\nfunction getEncoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    send: send,\n    maxBufferSize: MAX_BUFFER_SIZE,\n    minBufferSize: MIN_BUFFER_SIZE,\n    offset: 0,\n    start: 0\n  };\n  function fetch() {\n    var start = this.start;\n    if (start < this.offset) {\n      var end = this.start = this.offset;\n      return Bufferish.prototype.slice.call(this.buffer, start, end);\n    }\n  }\n  function flush() {\n    while (this.start < this.offset) {\n      var value = this.fetch();\n      if (value) this.push(value);\n    }\n  }\n  function pull() {\n    var buffers = this.buffers || (this.buffers = []);\n    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];\n    buffers.length = 0; // buffer exhausted\n    return chunk;\n  }\n  function reserve(length) {\n    var req = length | 0;\n    if (this.buffer) {\n      var size = this.buffer.length;\n      var start = this.offset | 0;\n      var end = start + req;\n\n      // is it long enough?\n      if (end < size) {\n        this.offset = end;\n        return start;\n      }\n\n      // flush current buffer\n      this.flush();\n\n      // resize it to 2x current length\n      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));\n    }\n\n    // minimum buffer size\n    length = Math.max(length, this.minBufferSize);\n\n    // allocate new buffer\n    this.buffer = this.bufferish.alloc(length);\n    this.start = 0;\n    this.offset = req;\n    return 0;\n  }\n  function send(buffer) {\n    var length = buffer.length;\n    if (length > this.minBufferSize) {\n      this.flush();\n      this.push(buffer);\n    } else {\n      var offset = this.reserve(length);\n      Bufferish.prototype.copy.call(buffer, this.buffer, offset);\n    }\n  }\n}\n\n// common methods\n\nfunction write() {\n  throw new Error(\"method not implemented: write()\");\n}\nfunction fetch() {\n  throw new Error(\"method not implemented: fetch()\");\n}\nfunction read() {\n  var length = this.buffers && this.buffers.length;\n\n  // fetch the first result\n  if (!length) return this.fetch();\n\n  // flush current buffer\n  this.flush();\n\n  // read from the results\n  return this.pull();\n}\nfunction push(chunk) {\n  var buffers = this.buffers || (this.buffers = []);\n  buffers.push(chunk);\n}\nfunction pull() {\n  var buffers = this.buffers || (this.buffers = []);\n  return buffers.shift();\n}\nfunction mixinFactory(source) {\n  return mixin;\n  function mixin(target) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n}","map":{"version":3,"names":["exports","FlexDecoder","FlexEncoder","Bufferish","require","MIN_BUFFER_SIZE","MAX_BUFFER_SIZE","BUFFER_SHORTAGE","mixin","mixinFactory","getDecoderMethods","prototype","getEncoderMethods","bufferish","write","fetch","flush","push","pull","read","reserve","offset","chunk","prev","slice","call","buffer","concat","length","start","value","e","message","end","Error","send","maxBufferSize","minBufferSize","buffers","req","size","Math","max","min","alloc","copy","shift","source","target","key"],"sources":["/Users/sultonbayevogabek/Projects/do-stmurod-vagonlar/node_modules/msgpack-lite/lib/flex-buffer.js"],"sourcesContent":["// flex-buffer.js\n\nexports.FlexDecoder = FlexDecoder;\nexports.FlexEncoder = FlexEncoder;\n\nvar Bufferish = require(\"./bufferish\");\n\nvar MIN_BUFFER_SIZE = 2048;\nvar MAX_BUFFER_SIZE = 65536;\nvar BUFFER_SHORTAGE = \"BUFFER_SHORTAGE\";\n\nfunction FlexDecoder() {\n  if (!(this instanceof FlexDecoder)) return new FlexDecoder();\n}\n\nfunction FlexEncoder() {\n  if (!(this instanceof FlexEncoder)) return new FlexEncoder();\n}\n\nFlexDecoder.mixin = mixinFactory(getDecoderMethods());\nFlexDecoder.mixin(FlexDecoder.prototype);\n\nFlexEncoder.mixin = mixinFactory(getEncoderMethods());\nFlexEncoder.mixin(FlexEncoder.prototype);\n\nfunction getDecoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    offset: 0\n  };\n\n  function write(chunk) {\n    var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;\n    this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;\n    this.offset = 0;\n  }\n\n  function flush() {\n    while (this.offset < this.buffer.length) {\n      var start = this.offset;\n      var value;\n      try {\n        value = this.fetch();\n      } catch (e) {\n        if (e && e.message != BUFFER_SHORTAGE) throw e;\n        // rollback\n        this.offset = start;\n        break;\n      }\n      this.push(value);\n    }\n  }\n\n  function reserve(length) {\n    var start = this.offset;\n    var end = start + length;\n    if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);\n    this.offset = end;\n    return start;\n  }\n}\n\nfunction getEncoderMethods() {\n  return {\n    bufferish: Bufferish,\n    write: write,\n    fetch: fetch,\n    flush: flush,\n    push: push,\n    pull: pull,\n    read: read,\n    reserve: reserve,\n    send: send,\n    maxBufferSize: MAX_BUFFER_SIZE,\n    minBufferSize: MIN_BUFFER_SIZE,\n    offset: 0,\n    start: 0\n  };\n\n  function fetch() {\n    var start = this.start;\n    if (start < this.offset) {\n      var end = this.start = this.offset;\n      return Bufferish.prototype.slice.call(this.buffer, start, end);\n    }\n  }\n\n  function flush() {\n    while (this.start < this.offset) {\n      var value = this.fetch();\n      if (value) this.push(value);\n    }\n  }\n\n  function pull() {\n    var buffers = this.buffers || (this.buffers = []);\n    var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];\n    buffers.length = 0; // buffer exhausted\n    return chunk;\n  }\n\n  function reserve(length) {\n    var req = length | 0;\n\n    if (this.buffer) {\n      var size = this.buffer.length;\n      var start = this.offset | 0;\n      var end = start + req;\n\n      // is it long enough?\n      if (end < size) {\n        this.offset = end;\n        return start;\n      }\n\n      // flush current buffer\n      this.flush();\n\n      // resize it to 2x current length\n      length = Math.max(length, Math.min(size * 2, this.maxBufferSize));\n    }\n\n    // minimum buffer size\n    length = Math.max(length, this.minBufferSize);\n\n    // allocate new buffer\n    this.buffer = this.bufferish.alloc(length);\n    this.start = 0;\n    this.offset = req;\n    return 0;\n  }\n\n  function send(buffer) {\n    var length = buffer.length;\n    if (length > this.minBufferSize) {\n      this.flush();\n      this.push(buffer);\n    } else {\n      var offset = this.reserve(length);\n      Bufferish.prototype.copy.call(buffer, this.buffer, offset);\n    }\n  }\n}\n\n// common methods\n\nfunction write() {\n  throw new Error(\"method not implemented: write()\");\n}\n\nfunction fetch() {\n  throw new Error(\"method not implemented: fetch()\");\n}\n\nfunction read() {\n  var length = this.buffers && this.buffers.length;\n\n  // fetch the first result\n  if (!length) return this.fetch();\n\n  // flush current buffer\n  this.flush();\n\n  // read from the results\n  return this.pull();\n}\n\nfunction push(chunk) {\n  var buffers = this.buffers || (this.buffers = []);\n  buffers.push(chunk);\n}\n\nfunction pull() {\n  var buffers = this.buffers || (this.buffers = []);\n  return buffers.shift();\n}\n\nfunction mixinFactory(source) {\n  return mixin;\n\n  function mixin(target) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}